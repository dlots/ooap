# Open-closed principle
Пример - иерархия классов в приложении-календаре.

Основные типы сущностей:
- "Календарь"
- "Задача"
- "Событие"

"Календарь" является основным классом. "Задача" и "Событие" являются базовыми классами, с которыми будет работать календарь. Эти классы определяют интерфейс сущностей, и базовую функциональность. Внесение изменений в интерфейс задачи и события потребует также изменения кода календаря. Внесение коренных изменений в реализации задачи и события без изменения интерфейса может непредсказуемым образом повлиять на поведение всей системы. Поэтому эти классы **закрыты для изменения/расширения**

Допустим, в какой то момент жизненного цикла проекта, оказалось необходимо добавить новую функциональность: дедлайны для задач, и возможность планировать звонки. Так как существующая иерархия классов закрыта для изменений, необходимо создать наследников, реализующих необходимую функциональность:
- "Задача с дедлайном" как наследник "Задачи"
- "Звонок" как наследник "События"

Во время разработки новой функциональности, "Задача с дедлайном" и "Звонок" будут **открыты для изменения/расширения**.

После выпуска функциональности в релиз новые классы будут закрыты для **изменения/расширения**.

Когда понадобится добавить возможность планировать конференц-звонки, необходимо будет расширить "Звонок", создав наследника "Конференция", так как "Звонок" уже закрыт для изменения.