# List hierarchy
Мое решение идентично образцу, за исключением того, что я **использовал композицию вместо наследования**. 
Rust не поддерживает наследование, но данная иерархия достаточно простая, поэтому я решил не менять язык и продолжить осваивать Rust.

В моей имплементации, определениями АТД служат _traits_ (аналог интерфейсов в Rust). АТД **LinkedList** и **TwoWayList** являются расширениями АТД **ParentList**, поэтому декларированы как _bounded traits_, требующие от структур также имплементировать **ParentList**.

Rust не поддерживает наследование, поэтому, чтобы избежать дублирования кода, имлементации "наследников" **ParentList** используют композицию, делегируя вызовы общих методов внутреннему экземпляру **ParentListImpl** (подобно тому, как имплементация АТД **BoundedStack** основана на встроенном типе **Vec**).

**LinkedList** предоставляет только новый конструктор, а остальные вызовы делегирует.

**TwoWayList** также вызывает методы **ParentList** при помощи **композиции**, а для расширения функциональности методом **left()**, имеет прямой доступ к полям **ParentList**, так как структуры определены в рамках одного _модуля_. Внешним пользователям поля **ParentListImpl** недоступны, тем самым не нарушается **инкапсуляция**. Также структура объявляет новое поле **left_status** и метод-запрос **get_left_status()**.

Таким образом, получилось реализовать такую иерархию, заменив наследование композицией, но при этом получилось соблюсти принципы требуемые в задании. Для более сложных примеров с наследованием/полиморфизмом, буду использовать другой язык (Java или Python).